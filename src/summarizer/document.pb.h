// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: summarizer/document.proto

#ifndef PROTOBUF_summarizer_2fdocument_2eproto__INCLUDED
#define PROTOBUF_summarizer_2fdocument_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace topicsum {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_summarizer_2fdocument_2eproto();
void protobuf_AssignDesc_summarizer_2fdocument_2eproto();
void protobuf_ShutdownFile_summarizer_2fdocument_2eproto();

class Sentence;
class Document;
class DocumentCollection;

// ===================================================================

class Sentence : public ::google::protobuf::Message {
 public:
  Sentence();
  virtual ~Sentence();
  
  Sentence(const Sentence& from);
  
  inline Sentence& operator=(const Sentence& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sentence& default_instance();
  
  void Swap(Sentence* other);
  
  // implements Message ----------------------------------------------
  
  Sentence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sentence& from);
  void MergeFrom(const Sentence& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string raw_content = 1;
  inline bool has_raw_content() const;
  inline void clear_raw_content();
  static const int kRawContentFieldNumber = 1;
  inline const ::std::string& raw_content() const;
  inline void set_raw_content(const ::std::string& value);
  inline void set_raw_content(const char* value);
  inline void set_raw_content(const char* value, size_t size);
  inline ::std::string* mutable_raw_content();
  inline ::std::string* release_raw_content();
  
  // repeated string token = 2;
  inline int token_size() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token(int index) const;
  inline ::std::string* mutable_token(int index);
  inline void set_token(int index, const ::std::string& value);
  inline void set_token(int index, const char* value);
  inline void set_token(int index, const char* value, size_t size);
  inline ::std::string* add_token();
  inline void add_token(const ::std::string& value);
  inline void add_token(const char* value);
  inline void add_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_token();
  
  // repeated string pos_tag = 5;
  inline int pos_tag_size() const;
  inline void clear_pos_tag();
  static const int kPosTagFieldNumber = 5;
  inline const ::std::string& pos_tag(int index) const;
  inline ::std::string* mutable_pos_tag(int index);
  inline void set_pos_tag(int index, const ::std::string& value);
  inline void set_pos_tag(int index, const char* value);
  inline void set_pos_tag(int index, const char* value, size_t size);
  inline ::std::string* add_pos_tag();
  inline void add_pos_tag(const ::std::string& value);
  inline void add_pos_tag(const char* value);
  inline void add_pos_tag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pos_tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pos_tag();
  
  // optional float prior_score = 8;
  inline bool has_prior_score() const;
  inline void clear_prior_score();
  static const int kPriorScoreFieldNumber = 8;
  inline float prior_score() const;
  inline void set_prior_score(float value);
  
  // optional float score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline float score() const;
  inline void set_score(float value);
  
  // optional string source_document = 4;
  inline bool has_source_document() const;
  inline void clear_source_document();
  static const int kSourceDocumentFieldNumber = 4;
  inline const ::std::string& source_document() const;
  inline void set_source_document(const ::std::string& value);
  inline void set_source_document(const char* value);
  inline void set_source_document(const char* value, size_t size);
  inline ::std::string* mutable_source_document();
  inline ::std::string* release_source_document();
  
  // @@protoc_insertion_point(class_scope:topicsum.Sentence)
 private:
  inline void set_has_raw_content();
  inline void clear_has_raw_content();
  inline void set_has_prior_score();
  inline void clear_has_prior_score();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_source_document();
  inline void clear_has_source_document();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* raw_content_;
  ::google::protobuf::RepeatedPtrField< ::std::string> token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pos_tag_;
  float prior_score_;
  float score_;
  ::std::string* source_document_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_summarizer_2fdocument_2eproto();
  friend void protobuf_AssignDesc_summarizer_2fdocument_2eproto();
  friend void protobuf_ShutdownFile_summarizer_2fdocument_2eproto();
  
  void InitAsDefaultInstance();
  static Sentence* default_instance_;
};
// -------------------------------------------------------------------

class Document : public ::google::protobuf::Message {
 public:
  Document();
  virtual ~Document();
  
  Document(const Document& from);
  
  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Document& default_instance();
  
  void Swap(Document* other);
  
  // implements Message ----------------------------------------------
  
  Document* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Document& from);
  void MergeFrom(const Document& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string id = 9;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 9;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional string description = 13;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 13;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional string raw_content = 2;
  inline bool has_raw_content() const;
  inline void clear_raw_content();
  static const int kRawContentFieldNumber = 2;
  inline const ::std::string& raw_content() const;
  inline void set_raw_content(const ::std::string& value);
  inline void set_raw_content(const char* value);
  inline void set_raw_content(const char* value, size_t size);
  inline ::std::string* mutable_raw_content();
  inline ::std::string* release_raw_content();
  
  // optional int64 publication_date = 3;
  inline bool has_publication_date() const;
  inline void clear_publication_date();
  static const int kPublicationDateFieldNumber = 3;
  inline ::google::protobuf::int64 publication_date() const;
  inline void set_publication_date(::google::protobuf::int64 value);
  
  // repeated .topicsum.Sentence sentence = 4;
  inline int sentence_size() const;
  inline void clear_sentence();
  static const int kSentenceFieldNumber = 4;
  inline const ::topicsum::Sentence& sentence(int index) const;
  inline ::topicsum::Sentence* mutable_sentence(int index);
  inline ::topicsum::Sentence* add_sentence();
  inline const ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence >&
      sentence() const;
  inline ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence >*
      mutable_sentence();
  
  // optional int64 num_tokens = 6;
  inline bool has_num_tokens() const;
  inline void clear_num_tokens();
  static const int kNumTokensFieldNumber = 6;
  inline ::google::protobuf::int64 num_tokens() const;
  inline void set_num_tokens(::google::protobuf::int64 value);
  
  // repeated .topicsum.Sentence title_sentence = 11;
  inline int title_sentence_size() const;
  inline void clear_title_sentence();
  static const int kTitleSentenceFieldNumber = 11;
  inline const ::topicsum::Sentence& title_sentence(int index) const;
  inline ::topicsum::Sentence* mutable_title_sentence(int index);
  inline ::topicsum::Sentence* add_title_sentence();
  inline const ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence >&
      title_sentence() const;
  inline ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence >*
      mutable_title_sentence();
  
  // optional int64 num_title_tokens = 12;
  inline bool has_num_title_tokens() const;
  inline void clear_num_title_tokens();
  static const int kNumTitleTokensFieldNumber = 12;
  inline ::google::protobuf::int64 num_title_tokens() const;
  inline void set_num_title_tokens(::google::protobuf::int64 value);
  
  // optional string debug_string = 7;
  inline bool has_debug_string() const;
  inline void clear_debug_string();
  static const int kDebugStringFieldNumber = 7;
  inline const ::std::string& debug_string() const;
  inline void set_debug_string(const ::std::string& value);
  inline void set_debug_string(const char* value);
  inline void set_debug_string(const char* value, size_t size);
  inline ::std::string* mutable_debug_string();
  inline ::std::string* release_debug_string();
  
  // optional bool dual = 8 [default = false];
  inline bool has_dual() const;
  inline void clear_dual();
  static const int kDualFieldNumber = 8;
  inline bool dual() const;
  inline void set_dual(bool value);
  
  // @@protoc_insertion_point(class_scope:topicsum.Document)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_raw_content();
  inline void clear_has_raw_content();
  inline void set_has_publication_date();
  inline void clear_has_publication_date();
  inline void set_has_num_tokens();
  inline void clear_has_num_tokens();
  inline void set_has_num_title_tokens();
  inline void clear_has_num_title_tokens();
  inline void set_has_debug_string();
  inline void clear_has_debug_string();
  inline void set_has_dual();
  inline void clear_has_dual();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* title_;
  ::std::string* description_;
  ::std::string* raw_content_;
  ::google::protobuf::int64 publication_date_;
  ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence > sentence_;
  ::google::protobuf::int64 num_tokens_;
  ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence > title_sentence_;
  ::google::protobuf::int64 num_title_tokens_;
  ::std::string* debug_string_;
  bool dual_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_summarizer_2fdocument_2eproto();
  friend void protobuf_AssignDesc_summarizer_2fdocument_2eproto();
  friend void protobuf_ShutdownFile_summarizer_2fdocument_2eproto();
  
  void InitAsDefaultInstance();
  static Document* default_instance_;
};
// -------------------------------------------------------------------

class DocumentCollection : public ::google::protobuf::Message {
 public:
  DocumentCollection();
  virtual ~DocumentCollection();
  
  DocumentCollection(const DocumentCollection& from);
  
  inline DocumentCollection& operator=(const DocumentCollection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentCollection& default_instance();
  
  void Swap(DocumentCollection* other);
  
  // implements Message ----------------------------------------------
  
  DocumentCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentCollection& from);
  void MergeFrom(const DocumentCollection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // repeated .topicsum.Document document = 2;
  inline int document_size() const;
  inline void clear_document();
  static const int kDocumentFieldNumber = 2;
  inline const ::topicsum::Document& document(int index) const;
  inline ::topicsum::Document* mutable_document(int index);
  inline ::topicsum::Document* add_document();
  inline const ::google::protobuf::RepeatedPtrField< ::topicsum::Document >&
      document() const;
  inline ::google::protobuf::RepeatedPtrField< ::topicsum::Document >*
      mutable_document();
  
  // optional int64 num_sentences = 3;
  inline bool has_num_sentences() const;
  inline void clear_num_sentences();
  static const int kNumSentencesFieldNumber = 3;
  inline ::google::protobuf::int64 num_sentences() const;
  inline void set_num_sentences(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:topicsum.DocumentCollection)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num_sentences();
  inline void clear_has_num_sentences();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::topicsum::Document > document_;
  ::google::protobuf::int64 num_sentences_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_summarizer_2fdocument_2eproto();
  friend void protobuf_AssignDesc_summarizer_2fdocument_2eproto();
  friend void protobuf_ShutdownFile_summarizer_2fdocument_2eproto();
  
  void InitAsDefaultInstance();
  static DocumentCollection* default_instance_;
};
// ===================================================================


// ===================================================================

// Sentence

// optional string raw_content = 1;
inline bool Sentence::has_raw_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sentence::set_has_raw_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sentence::clear_has_raw_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sentence::clear_raw_content() {
  if (raw_content_ != &::google::protobuf::internal::kEmptyString) {
    raw_content_->clear();
  }
  clear_has_raw_content();
}
inline const ::std::string& Sentence::raw_content() const {
  return *raw_content_;
}
inline void Sentence::set_raw_content(const ::std::string& value) {
  set_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    raw_content_ = new ::std::string;
  }
  raw_content_->assign(value);
}
inline void Sentence::set_raw_content(const char* value) {
  set_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    raw_content_ = new ::std::string;
  }
  raw_content_->assign(value);
}
inline void Sentence::set_raw_content(const char* value, size_t size) {
  set_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    raw_content_ = new ::std::string;
  }
  raw_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Sentence::mutable_raw_content() {
  set_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    raw_content_ = new ::std::string;
  }
  return raw_content_;
}
inline ::std::string* Sentence::release_raw_content() {
  clear_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = raw_content_;
    raw_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string token = 2;
inline int Sentence::token_size() const {
  return token_.size();
}
inline void Sentence::clear_token() {
  token_.Clear();
}
inline const ::std::string& Sentence::token(int index) const {
  return token_.Get(index);
}
inline ::std::string* Sentence::mutable_token(int index) {
  return token_.Mutable(index);
}
inline void Sentence::set_token(int index, const ::std::string& value) {
  token_.Mutable(index)->assign(value);
}
inline void Sentence::set_token(int index, const char* value) {
  token_.Mutable(index)->assign(value);
}
inline void Sentence::set_token(int index, const char* value, size_t size) {
  token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Sentence::add_token() {
  return token_.Add();
}
inline void Sentence::add_token(const ::std::string& value) {
  token_.Add()->assign(value);
}
inline void Sentence::add_token(const char* value) {
  token_.Add()->assign(value);
}
inline void Sentence::add_token(const char* value, size_t size) {
  token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Sentence::token() const {
  return token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Sentence::mutable_token() {
  return &token_;
}

// repeated string pos_tag = 5;
inline int Sentence::pos_tag_size() const {
  return pos_tag_.size();
}
inline void Sentence::clear_pos_tag() {
  pos_tag_.Clear();
}
inline const ::std::string& Sentence::pos_tag(int index) const {
  return pos_tag_.Get(index);
}
inline ::std::string* Sentence::mutable_pos_tag(int index) {
  return pos_tag_.Mutable(index);
}
inline void Sentence::set_pos_tag(int index, const ::std::string& value) {
  pos_tag_.Mutable(index)->assign(value);
}
inline void Sentence::set_pos_tag(int index, const char* value) {
  pos_tag_.Mutable(index)->assign(value);
}
inline void Sentence::set_pos_tag(int index, const char* value, size_t size) {
  pos_tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Sentence::add_pos_tag() {
  return pos_tag_.Add();
}
inline void Sentence::add_pos_tag(const ::std::string& value) {
  pos_tag_.Add()->assign(value);
}
inline void Sentence::add_pos_tag(const char* value) {
  pos_tag_.Add()->assign(value);
}
inline void Sentence::add_pos_tag(const char* value, size_t size) {
  pos_tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Sentence::pos_tag() const {
  return pos_tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Sentence::mutable_pos_tag() {
  return &pos_tag_;
}

// optional float prior_score = 8;
inline bool Sentence::has_prior_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sentence::set_has_prior_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Sentence::clear_has_prior_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Sentence::clear_prior_score() {
  prior_score_ = 0;
  clear_has_prior_score();
}
inline float Sentence::prior_score() const {
  return prior_score_;
}
inline void Sentence::set_prior_score(float value) {
  set_has_prior_score();
  prior_score_ = value;
}

// optional float score = 3;
inline bool Sentence::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sentence::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Sentence::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Sentence::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float Sentence::score() const {
  return score_;
}
inline void Sentence::set_score(float value) {
  set_has_score();
  score_ = value;
}

// optional string source_document = 4;
inline bool Sentence::has_source_document() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Sentence::set_has_source_document() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Sentence::clear_has_source_document() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Sentence::clear_source_document() {
  if (source_document_ != &::google::protobuf::internal::kEmptyString) {
    source_document_->clear();
  }
  clear_has_source_document();
}
inline const ::std::string& Sentence::source_document() const {
  return *source_document_;
}
inline void Sentence::set_source_document(const ::std::string& value) {
  set_has_source_document();
  if (source_document_ == &::google::protobuf::internal::kEmptyString) {
    source_document_ = new ::std::string;
  }
  source_document_->assign(value);
}
inline void Sentence::set_source_document(const char* value) {
  set_has_source_document();
  if (source_document_ == &::google::protobuf::internal::kEmptyString) {
    source_document_ = new ::std::string;
  }
  source_document_->assign(value);
}
inline void Sentence::set_source_document(const char* value, size_t size) {
  set_has_source_document();
  if (source_document_ == &::google::protobuf::internal::kEmptyString) {
    source_document_ = new ::std::string;
  }
  source_document_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Sentence::mutable_source_document() {
  set_has_source_document();
  if (source_document_ == &::google::protobuf::internal::kEmptyString) {
    source_document_ = new ::std::string;
  }
  return source_document_;
}
inline ::std::string* Sentence::release_source_document() {
  clear_has_source_document();
  if (source_document_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_document_;
    source_document_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Document

// optional string id = 9;
inline bool Document::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Document::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Document::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Document::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Document::id() const {
  return *id_;
}
inline void Document::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Document::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Document::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Document::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string title = 1;
inline bool Document::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Document::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Document::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Document::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Document::title() const {
  return *title_;
}
inline void Document::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Document::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Document::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Document::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string description = 13;
inline bool Document::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Document::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Document::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Document::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Document::description() const {
  return *description_;
}
inline void Document::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Document::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Document::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Document::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string raw_content = 2;
inline bool Document::has_raw_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Document::set_has_raw_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Document::clear_has_raw_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Document::clear_raw_content() {
  if (raw_content_ != &::google::protobuf::internal::kEmptyString) {
    raw_content_->clear();
  }
  clear_has_raw_content();
}
inline const ::std::string& Document::raw_content() const {
  return *raw_content_;
}
inline void Document::set_raw_content(const ::std::string& value) {
  set_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    raw_content_ = new ::std::string;
  }
  raw_content_->assign(value);
}
inline void Document::set_raw_content(const char* value) {
  set_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    raw_content_ = new ::std::string;
  }
  raw_content_->assign(value);
}
inline void Document::set_raw_content(const char* value, size_t size) {
  set_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    raw_content_ = new ::std::string;
  }
  raw_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_raw_content() {
  set_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    raw_content_ = new ::std::string;
  }
  return raw_content_;
}
inline ::std::string* Document::release_raw_content() {
  clear_has_raw_content();
  if (raw_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = raw_content_;
    raw_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 publication_date = 3;
inline bool Document::has_publication_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Document::set_has_publication_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Document::clear_has_publication_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Document::clear_publication_date() {
  publication_date_ = GOOGLE_LONGLONG(0);
  clear_has_publication_date();
}
inline ::google::protobuf::int64 Document::publication_date() const {
  return publication_date_;
}
inline void Document::set_publication_date(::google::protobuf::int64 value) {
  set_has_publication_date();
  publication_date_ = value;
}

// repeated .topicsum.Sentence sentence = 4;
inline int Document::sentence_size() const {
  return sentence_.size();
}
inline void Document::clear_sentence() {
  sentence_.Clear();
}
inline const ::topicsum::Sentence& Document::sentence(int index) const {
  return sentence_.Get(index);
}
inline ::topicsum::Sentence* Document::mutable_sentence(int index) {
  return sentence_.Mutable(index);
}
inline ::topicsum::Sentence* Document::add_sentence() {
  return sentence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence >&
Document::sentence() const {
  return sentence_;
}
inline ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence >*
Document::mutable_sentence() {
  return &sentence_;
}

// optional int64 num_tokens = 6;
inline bool Document::has_num_tokens() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Document::set_has_num_tokens() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Document::clear_has_num_tokens() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Document::clear_num_tokens() {
  num_tokens_ = GOOGLE_LONGLONG(0);
  clear_has_num_tokens();
}
inline ::google::protobuf::int64 Document::num_tokens() const {
  return num_tokens_;
}
inline void Document::set_num_tokens(::google::protobuf::int64 value) {
  set_has_num_tokens();
  num_tokens_ = value;
}

// repeated .topicsum.Sentence title_sentence = 11;
inline int Document::title_sentence_size() const {
  return title_sentence_.size();
}
inline void Document::clear_title_sentence() {
  title_sentence_.Clear();
}
inline const ::topicsum::Sentence& Document::title_sentence(int index) const {
  return title_sentence_.Get(index);
}
inline ::topicsum::Sentence* Document::mutable_title_sentence(int index) {
  return title_sentence_.Mutable(index);
}
inline ::topicsum::Sentence* Document::add_title_sentence() {
  return title_sentence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence >&
Document::title_sentence() const {
  return title_sentence_;
}
inline ::google::protobuf::RepeatedPtrField< ::topicsum::Sentence >*
Document::mutable_title_sentence() {
  return &title_sentence_;
}

// optional int64 num_title_tokens = 12;
inline bool Document::has_num_title_tokens() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Document::set_has_num_title_tokens() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Document::clear_has_num_title_tokens() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Document::clear_num_title_tokens() {
  num_title_tokens_ = GOOGLE_LONGLONG(0);
  clear_has_num_title_tokens();
}
inline ::google::protobuf::int64 Document::num_title_tokens() const {
  return num_title_tokens_;
}
inline void Document::set_num_title_tokens(::google::protobuf::int64 value) {
  set_has_num_title_tokens();
  num_title_tokens_ = value;
}

// optional string debug_string = 7;
inline bool Document::has_debug_string() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Document::set_has_debug_string() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Document::clear_has_debug_string() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Document::clear_debug_string() {
  if (debug_string_ != &::google::protobuf::internal::kEmptyString) {
    debug_string_->clear();
  }
  clear_has_debug_string();
}
inline const ::std::string& Document::debug_string() const {
  return *debug_string_;
}
inline void Document::set_debug_string(const ::std::string& value) {
  set_has_debug_string();
  if (debug_string_ == &::google::protobuf::internal::kEmptyString) {
    debug_string_ = new ::std::string;
  }
  debug_string_->assign(value);
}
inline void Document::set_debug_string(const char* value) {
  set_has_debug_string();
  if (debug_string_ == &::google::protobuf::internal::kEmptyString) {
    debug_string_ = new ::std::string;
  }
  debug_string_->assign(value);
}
inline void Document::set_debug_string(const char* value, size_t size) {
  set_has_debug_string();
  if (debug_string_ == &::google::protobuf::internal::kEmptyString) {
    debug_string_ = new ::std::string;
  }
  debug_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_debug_string() {
  set_has_debug_string();
  if (debug_string_ == &::google::protobuf::internal::kEmptyString) {
    debug_string_ = new ::std::string;
  }
  return debug_string_;
}
inline ::std::string* Document::release_debug_string() {
  clear_has_debug_string();
  if (debug_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_string_;
    debug_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool dual = 8 [default = false];
inline bool Document::has_dual() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Document::set_has_dual() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Document::clear_has_dual() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Document::clear_dual() {
  dual_ = false;
  clear_has_dual();
}
inline bool Document::dual() const {
  return dual_;
}
inline void Document::set_dual(bool value) {
  set_has_dual();
  dual_ = value;
}

// -------------------------------------------------------------------

// DocumentCollection

// optional string id = 1;
inline bool DocumentCollection::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentCollection::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentCollection::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentCollection::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& DocumentCollection::id() const {
  return *id_;
}
inline void DocumentCollection::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DocumentCollection::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DocumentCollection::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentCollection::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* DocumentCollection::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .topicsum.Document document = 2;
inline int DocumentCollection::document_size() const {
  return document_.size();
}
inline void DocumentCollection::clear_document() {
  document_.Clear();
}
inline const ::topicsum::Document& DocumentCollection::document(int index) const {
  return document_.Get(index);
}
inline ::topicsum::Document* DocumentCollection::mutable_document(int index) {
  return document_.Mutable(index);
}
inline ::topicsum::Document* DocumentCollection::add_document() {
  return document_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::topicsum::Document >&
DocumentCollection::document() const {
  return document_;
}
inline ::google::protobuf::RepeatedPtrField< ::topicsum::Document >*
DocumentCollection::mutable_document() {
  return &document_;
}

// optional int64 num_sentences = 3;
inline bool DocumentCollection::has_num_sentences() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentCollection::set_has_num_sentences() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentCollection::clear_has_num_sentences() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentCollection::clear_num_sentences() {
  num_sentences_ = GOOGLE_LONGLONG(0);
  clear_has_num_sentences();
}
inline ::google::protobuf::int64 DocumentCollection::num_sentences() const {
  return num_sentences_;
}
inline void DocumentCollection::set_num_sentences(::google::protobuf::int64 value) {
  set_has_num_sentences();
  num_sentences_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace topicsum

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_summarizer_2fdocument_2eproto__INCLUDED
